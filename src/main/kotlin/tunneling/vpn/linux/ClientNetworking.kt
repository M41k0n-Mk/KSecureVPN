package tunneling.vpn.linux

import logging.LogLevel
import logging.SecureLogger

/**
 * Automação de rede no cliente Linux: configura TUN com IP/MTU, rota default opcional e DNS.
 */
object ClientNetworking {
    private val logger = SecureLogger.getInstance()

    fun configureLinuxClient(
        tunName: String,
        ipCidr: String,
        mtu: Int,
        setDefaultRoute: Boolean,
        dnsServersCsv: String,
    ) {
        if (!isLinux()) {
            logger.logSessionEvent("client-net", LogLevel.INFO, "Client auto-network skipped (not Linux)")
            return
        }

        runSafe(listOf("ip", "link", "set", "dev", tunName, "up"), "bring up $tunName")
        runSafe(listOf("ip", "addr", "flush", "dev", tunName), "flush addr $tunName")
        runSafe(listOf("ip", "addr", "add", ipCidr, "dev", tunName), "assign $ipCidr to $tunName")
        runSafe(listOf("ip", "link", "set", "dev", tunName, "mtu", mtu.toString()), "set MTU $mtu")

        if (setDefaultRoute) {
            runSafe(listOf("ip", "route", "del", "default"), "remove default route", continueOnFail = true)
            runSafe(listOf("ip", "route", "add", "default", "dev", tunName), "add default route via $tunName")
        }

        // DNS (best-effort): tenta systemd-resolved, senão /etc/resolv.conf
        val servers = dnsServersCsv.split(',').map { it.trim() }.filter { it.isNotEmpty() }
        if (servers.isNotEmpty()) {
            // systemd-resolved
            val srv = servers.joinToString(" ")
            val rc = runSafe(listOf("resolvectl", "dns", tunName, srv), "set DNS via systemd-resolved", continueOnFail = true)
            if (rc != 0) {
                // fallback: sobrescrever /etc/resolv.conf (requer privilégios)
                val content =
                    buildString {
                        appendLine("# Generated by KSecureVPN client")
                        servers.forEach { appendLine("nameserver $it") }
                    }
                try {
                    val proc = ProcessBuilder("/bin/sh", "-c", "printf '%s' \"$content\" > /etc/resolv.conf").start()
                    val exit = proc.waitFor()
                    if (exit != 0) {
                        logger.logSessionEvent("client-net", LogLevel.WARN, "Falha ao escrever /etc/resolv.conf (exit=$exit)")
                    }
                } catch (e: Exception) {
                    logger.logSessionEvent("client-net", LogLevel.WARN, "Exceção ao definir DNS: ${e.message}")
                }
            }
        }
    }

    private fun isLinux(): Boolean = System.getProperty("os.name")?.lowercase()?.contains("linux") == true

    private fun runSafe(
        cmd: List<String>,
        desc: String,
        continueOnFail: Boolean = false,
    ): Int {
        return try {
            val proc = ProcessBuilder(cmd).redirectErrorStream(true).start()
            val out = proc.inputStream.bufferedReader().readText()
            val exit = proc.waitFor()
            if (exit != 0) {
                val msg = "$desc failed (exit=$exit): ${out.trim()}"
                if (continueOnFail) {
                    logger.logSessionEvent("client-net", LogLevel.WARN, msg)
                } else {
                    throw IllegalStateException(msg)
                }
            } else {
                if (out.isNotBlank()) {
                    logger.logSessionEvent("client-net", LogLevel.DEBUG, "$desc ok: ${out.trim()}")
                } else {
                    logger.logSessionEvent("client-net", LogLevel.INFO, "$desc ok")
                }
            }
            exit
        } catch (e: Exception) {
            val msg = "$desc exception: ${e.message}"
            if (continueOnFail) {
                logger.logSessionEvent("client-net", LogLevel.WARN, msg)
                return -1
            } else {
                throw e
            }
        }
    }
}
